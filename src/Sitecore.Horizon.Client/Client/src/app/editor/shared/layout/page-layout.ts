/*!
 * © Sitecore Corporation A/S. All rights reserved. Sitecore® is a registered trademark of Sitecore Corporation A/S.
 */

import { removeFromArray } from '@sitecore/horizon-messaging/dist/utils';
import { PageUpdateOptions } from 'app/editor/canvas-page/canvas-page-state';
import { EditorWorkspaceService } from 'app/editor/editor-workspace/editor-workspace.service';
import { Context } from 'app/shared/client-state/context.service';
import { EditingMessagingChannel } from 'app/shared/messaging/horizon-canvas.contract.defs';
import { DeepReadonly } from 'app/shared/utils/lang.utils';
import { Lifespan } from 'app/shared/utils/lifetime';
import { isSameGuid, moveItemInArray, pickDefinedProperties } from 'app/shared/utils/utils';
import { RenderingInitializationContext, RenderingInitializationDetails } from 'sdk';
import { v4 as uuid } from 'uuid';
import {
  LayoutDeviceDefinition,
  LayoutRenderingDefinition,
  PageLayoutDefinition,
  Rule,
} from './page-layout-definition';

const DEFAULT_RULE_UNIQUE_ID = '{00000000-0000-0000-0000-000000000000}';

export type PlacementAnchorPosition = 'before' | 'after';

export interface PlacementAnchor<T> {
  readonly target: T;
  readonly position: PlacementAnchorPosition;
}

export interface RenderingDefinition extends Omit<LayoutRenderingDefinition, 'dataSource'> {
  dataSource: string | null;
}

export type RenderingDefinitionUpdate = Partial<Readonly<Omit<RenderingDefinition, 'instanceId'>>>;

export interface RenderingsDefinitionUpdates {
  renderingInstanceId: string;
  update: RenderingDefinitionUpdate;
}

export interface PersonalizationRules {
  renderingInstanceId: string;
  rules: Rule[];
}

export interface PageLayoutHooks {
  hookInsertRendering(context: RenderingInitializationContext): Promise<RenderingInitializationContext>;
}

export type LayoutChangeListener = (options: PageUpdateOptions) => Promise<void>;

export class PageLayout {
  private layout: PageLayoutDefinition = { devices: [] };

  private readonly onLayoutChangeListeners: LayoutChangeListener[] = [];

  constructor(
    layout: string,
    private readonly deviceId: string,
    private readonly hooks: PageLayoutHooks,
    private readonly editingChannel: EditingMessagingChannel,
    private readonly context: Context,
    private readonly editorWorkspaceService: EditorWorkspaceService,
  ) {
    this.layout = JSON.parse(layout) as PageLayoutDefinition;
  }

  static isSameLayout(left?: string, right?: string): boolean {
    if (left === right) {
      return true;
    }

    if (!left || !right) {
      return false;
    }

    const leftDef = PageLayout.parseLayoutDefinition(left);
    const rightDef = PageLayout.parseLayoutDefinition(right);

    stripUncontrolledValues(leftDef);
    stripUncontrolledValues(rightDef);

    return PageLayout.stringifyLayoutDefinition(leftDef) === PageLayout.stringifyLayoutDefinition(rightDef);

    // Some values of the layout can be changed by the BE out of the application's control
    // That confuses history.
    // Ignore that difference by normalizing the field values.
    function stripUncontrolledValues(layout: PageLayoutDefinition) {
      const STABLE_PERSONALIZATION_TEST_ID = '05b43efc-65a5-408c-8ccc-c7e7001fb9dc';

      for (const device of layout.devices) {
        for (const rendering of device.renderings) {
          // parameters dynamic placeholder is automatically generated by platform
          if (rendering.parameters?.DynamicPlaceholderId) {
            rendering.parameters.DynamicPlaceholderId = '';
          }
          if (rendering.personalization) {
            // ContentTesting is automatically generating new test IDs on each save.
            if (rendering.personalization.personalizationTest) {
              rendering.personalization.personalizationTest = STABLE_PERSONALIZATION_TEST_ID;
            }

            // rule parameters are unknown to our UI - so ignore them
            rendering.personalization.ruleSet?.rules?.forEach((rule) => {
              rule.parameters = {};
              rule.actions?.forEach((action) => (action.parameters = {}));
            });
          }
        }
      }
    }
  }

  static parseLayoutDefinition(layout: string): PageLayoutDefinition {
    return JSON.parse(layout) as PageLayoutDefinition;
  }

  static stringifyLayoutDefinition(layoutDef: PageLayoutDefinition): string {
    return JSON.stringify(layoutDef);
  }

  static encodeRenderingParameters(layout: string): string {
    const parsedLayout = PageLayout.parseLayoutDefinition(layout);
    for (const device of parsedLayout.devices) {
      for (const rendering of device.renderings) {
        if (rendering.parameters) {
          for (const paramKey in rendering.parameters) {
            if (Object.prototype.hasOwnProperty.call(rendering.parameters, paramKey)) {
              rendering.parameters[paramKey] = encodeURIComponent(rendering.parameters[paramKey]);
            }
          }
        }
      }
    }

    return PageLayout.stringifyLayoutDefinition(parsedLayout);
  }

  private static buildCanonicalRenderingDefinition(rendering: LayoutRenderingDefinition): LayoutRenderingDefinition {
    // Notice, order matters. Properties should be in exactly same order as in schema.
    // Otherwise after save BE will return them in a different order and that will be considered as a change.

    return {
      id: rendering.id,
      instanceId: rendering.instanceId,
      placeholderKey: rendering.placeholderKey,
      dataSource: rendering.dataSource || undefined,
      parameters: rendering.parameters,
      caching: rendering.caching,
      personalization: rendering.personalization,
    };
  }

  getLayoutSnapshot(): string {
    return PageLayout.stringifyLayoutDefinition(this.layout);
  }

  async setLayoutSnapshot(layout: string, silent: boolean = false): Promise<void> {
    if (PageLayout.isSameLayout(this.getLayoutSnapshot(), layout)) {
      return;
    }

    this.layout = PageLayout.parseLayoutDefinition(layout);

    if (!silent) {
      await this.emitLayoutChange({ reloadCanvas: true, skipHistory: false });
    }
  }

  async insertRendering(
    renderingId: string,
    placeholderKey: string,
    placement: PlacementAnchor<string> | undefined,
  ): Promise<boolean> {
    this.editorWorkspaceService.setCanvasLoadState({ isLoading: true });

    // Use randomly generated UUID (version 4)
    const instanceId = uuid();
    // initialize rendering
    const renderingDetailsDraft: RenderingInitializationDetails = {
      renderingId,
      instanceId,
      placeholderKey,
      parameters: {},
      dataSource: null,
    };
    const { renderingDetails, cancelRenderingInsert } = await this.hooks.hookInsertRendering({
      renderingDetails: renderingDetailsDraft,
      cancelRenderingInsert: false,
    });
    if (cancelRenderingInsert) {
      this.editorWorkspaceService.setCanvasLoadState({
        isLoading: false,
        itemId: this.context.itemId,
        language: this.context.language,
      });
      return false;
    }

    const newRenderingEntry = PageLayout.buildCanonicalRenderingDefinition({
      id: renderingDetails.renderingId,
      instanceId,
      placeholderKey: renderingDetails.placeholderKey,
      dataSource: renderingDetails.dataSource || undefined,
      parameters: renderingDetails.parameters,
    });

    const device = this.getCurrentLayoutDevice();
    this.insertRenderingIntoPlacement(device, newRenderingEntry, placement);

    await this.emitLayoutChange({
      reloadCanvas: true,
      skipHistory: false,
      chromeToSelect: { chromeId: instanceId, chromeType: 'rendering' },
    });
    return true;
  }

  async moveRendering(
    renderingInstanceId: string,
    placeholderKey: string,
    placement: PlacementAnchor<string> | undefined,
    skipHistory = false,
  ): Promise<boolean> {
    const device = this.getCurrentLayoutDevice();
    const rendering = device.renderings.filter((r) => isSameGuid(r.instanceId, renderingInstanceId))[0];
    if (!rendering) {
      return false;
    }

    const originalPlaceholderKey = rendering.placeholderKey;

    // move all child renderings to the new placeholder
    const childPlaceholders = await this.editingChannel.rpc.getChildPlaceholders(renderingInstanceId);
    const childPlaceholdersKeys = childPlaceholders.map((ph) => ph.placeholderKey);
    const childRenderings = device.renderings.filter((ren) =>
      childPlaceholdersKeys.some((phKey) => this.renderingBelongsToPlaceholder(ren, phKey)),
    );
    childRenderings.forEach((childRendering) => {
      let newKey = childRendering.placeholderKey.replace(originalPlaceholderKey, placeholderKey);
      // ph key that consist of at least 2 parts should start with slash
      // ph key on root level doesn't start with slash
      // there are scenarios of moving rendering from root level ph to nested ph or wise versa
      // replacing ph in code line above may result in double slashes or absence of slash in the beginning of the ph key
      newKey = newKey.replace('//', '/');
      newKey = newKey.startsWith('/') ? newKey : `/${newKey}`;
      childRendering.placeholderKey = newKey;
    });

    // mover rendering to the new placeholder/position
    device.renderings = device.renderings.filter((r) => !isSameGuid(r.instanceId, renderingInstanceId));
    rendering.placeholderKey = placeholderKey;
    this.insertRenderingIntoPlacement(device, rendering, placement);

    await this.emitLayoutChange({
      reloadCanvas: false,
      skipHistory,
      chromeToSelect: { chromeId: renderingInstanceId, chromeType: 'rendering' },
    });
    return true;
  }

  /**
   * Look up rendering by ID and return null if not found
   */
  findRendering(instanceId: string): DeepReadonly<RenderingDefinition> | null {
    const device = this.getCurrentLayoutDevice();
    const rendering = device.renderings.find((r) => isSameGuid(r.instanceId, instanceId));
    return rendering ? { ...rendering, dataSource: rendering.dataSource || null } : null;
  }

  /**
   * Get rendering by ID and fail if does not exist
   */
  getRendering(instanceId: string): DeepReadonly<RenderingDefinition> {
    const result = this.findRendering(instanceId);
    if (!result) {
      throw new Error(`Cannot find rendering by id: ${instanceId}`);
    }

    return result;
  }

  getAllRenderings(): RenderingDefinition[] {
    const device = this.getCurrentLayoutDevice();
    const renderings = [...device.renderings];
    return renderings.map((r) => {
      return { ...r, dataSource: r.dataSource || null };
    });
  }

  async removeRendering(instanceId: string, skipHistory = false, updateCanvas = true): Promise<void> {
    const device = this.getCurrentLayoutDevice();

    const childPlaceholders = await this.editingChannel.rpc.getChildPlaceholders(instanceId);
    const childPlaceholdersKeys = childPlaceholders.map((ph) => ph.placeholderKey);

    // remove rendering
    device.renderings = device.renderings.filter((rendering) => !isSameGuid(rendering.instanceId, instanceId));
    // remove child renderings
    device.renderings = device.renderings.filter(
      (rendering) => !childPlaceholdersKeys.some((phKey) => this.renderingBelongsToPlaceholder(rendering, phKey)),
    );

    if (updateCanvas) {
      this.editingChannel.emit('canvas:change-dom', {
        eventType: 'remove',
        chromeType: 'rendering',
        renderingInstanceId: instanceId,
      });
    }
    await this.emitLayoutChange({ reloadCanvas: false, skipHistory });
  }

  async moveRenderingWithinSamePlaceholder(instanceId: string, direction: 'up' | 'down'): Promise<void> {
    const device = this.getCurrentLayoutDevice();
    const renderings = [...device.renderings];
    const renderingToMove = renderings.find((item) => isSameGuid(item.instanceId, instanceId));
    const placeholderKey = renderingToMove?.placeholderKey;

    if (!renderingToMove || !placeholderKey) {
      return;
    }

    const anotherPlaceholderRenderings = renderings.filter((item) => item.placeholderKey !== placeholderKey);
    let samePlaceholderRenderings = renderings.filter((item) => item.placeholderKey === placeholderKey);

    const currentIndex = samePlaceholderRenderings.indexOf(renderingToMove);
    const newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;

    samePlaceholderRenderings = moveItemInArray(samePlaceholderRenderings, currentIndex, newIndex);

    device.renderings = [...anotherPlaceholderRenderings, ...samePlaceholderRenderings];

    this.editingChannel.emit('canvas:change-dom', {
      eventType: 'rearrangeInSamePlaceholder',
      chromeType: 'rendering',
      direction,
      renderingInstanceId: instanceId,
    });
    await this.emitLayoutChange({ reloadCanvas: false, skipHistory: false });
  }

  async updateRenderings(
    updates: RenderingsDefinitionUpdates[],
    options: PageUpdateOptions = { reloadCanvas: true, skipHistory: false },
  ): Promise<void> {
    if (updates.length) {
      updates.forEach((i) => {
        this.updateRenderingDefinition(i.renderingInstanceId, i.update);
      });

      await this.emitLayoutChange(options);
    }
  }

  async setRenderingsPersonalizationRules(
    personalizationRules: PersonalizationRules[],
    reloadCanvas = true,
  ): Promise<void> {
    const renderingsUpdates: RenderingsDefinitionUpdates[] = [];

    if (personalizationRules.length) {
      personalizationRules.forEach((i) => {
        if (i.rules.length === 1 && i.rules[0].uniqueId === DEFAULT_RULE_UNIQUE_ID && !i.rules[0].actions?.length) {
          renderingsUpdates.push({
            renderingInstanceId: i.renderingInstanceId,
            update: { personalization: {} },
          });
        } else {
          renderingsUpdates.push({
            renderingInstanceId: i.renderingInstanceId,
            update: {
              personalization: {
                ruleSet: { pet: true, rules: i.rules },
              },
            },
          });
        }
      });

      await this.updateRenderings(renderingsUpdates, { reloadCanvas, skipHistory: false });
    }
  }

  getRenderingPersonalizationRules(instanceId: string): Rule[] {
    const rendering = this.getRendering(instanceId);
    const rules = rendering.personalization?.ruleSet?.rules;
    return rules ? [...rules] : [];
  }

  onLayoutChange(lifespan: Lifespan, listener: LayoutChangeListener) {
    this.onLayoutChangeListeners.push(listener);

    lifespan.registerCallbacks(() => removeFromArray(listener, this.onLayoutChangeListeners));
  }

  private getCurrentLayoutDevice(): LayoutDeviceDefinition {
    return this.getLayoutDeviceById(this.deviceId);
  }

  private getLayoutDeviceById(deviceId: string): LayoutDeviceDefinition {
    const node = this.layout.devices.find((d) => isSameGuid(d.id, deviceId));
    if (!node) {
      throw Error(`Device '${this.deviceId}' was not found.`);
    }

    return node;
  }

  private updateRenderingDefinition(instanceId: string, update: RenderingDefinitionUpdate) {
    const device = this.getCurrentLayoutDevice();
    const renderingIndex = device.renderings.findIndex((r) => isSameGuid(r.instanceId, instanceId));
    if (renderingIndex === -1) {
      console.warn(`Rendering with instance id '${instanceId}' was not found.`);
      return;
    }

    const newRendering = PageLayout.buildCanonicalRenderingDefinition({
      ...device.renderings[renderingIndex],

      // Re-pick properties so user cannot rewrite instanceId
      ...pickDefinedProperties(update, ['caching', 'id', 'parameters', 'personalization', 'placeholderKey']),

      // Use current dataSource value if update is undefined. Remove dataSource if null or empty string.
      ...(update.dataSource !== undefined && { dataSource: update.dataSource || undefined }),
    });

    // Updating the layout
    device.renderings[renderingIndex] = newRendering;
  }

  private async emitLayoutChange(options: PageUpdateOptions): Promise<void> {
    for (const listener of this.onLayoutChangeListeners) {
      await listener(options);
    }
  }

  private insertRenderingIntoPlacement(
    device: LayoutDeviceDefinition,
    rendering: LayoutRenderingDefinition,
    placement: PlacementAnchor<string> | undefined,
  ) {
    let anchorIndex = -1;
    if (placement) {
      anchorIndex = device.renderings.findIndex((r) => isSameGuid(r.instanceId, placement.target));

      if (placement.position === 'after' && anchorIndex !== -1) {
        // If current rendering is the latest one and we want to insert after, just append to the end of renderings.
        anchorIndex = anchorIndex === device.renderings.length - 1 ? -1 : anchorIndex + 1;
      }
    }

    if (anchorIndex !== -1) {
      device.renderings.splice(anchorIndex, 0, rendering);
    } else {
      device.renderings.push(rendering);
    }
  }

  private renderingBelongsToPlaceholder(rendering: LayoutRenderingDefinition, placeholderKey: string): boolean {
    const phKeyWithTrailingSlash = placeholderKey.endsWith('/') ? placeholderKey : `${placeholderKey}/`;
    return rendering.placeholderKey === placeholderKey || rendering.placeholderKey.startsWith(phKeyWithTrailingSlash);
  }
}
